{"version":3,"file":"adag.js","sources":["dag.js"],"sourcesContent":["export function createEdge(a, b) {\n    return [a.id, b.id];\n}\nexport class DAG {\n    constructor() {\n        this.vertices = new Map();\n        this.inEdges = new Map();\n        this.outEdges = new Map();\n    }\n    clear() {\n        this.vertices.clear();\n        this.inEdges.clear();\n        this.outEdges.clear();\n    }\n    addVertex(...vertices) {\n        for (const v of vertices) {\n            this.vertices.set(v.id, v);\n            this.inEdges.set(v.id, new Set());\n            this.outEdges.set(v.id, new Set());\n        }\n    }\n    getVertex(id) {\n        return this.vertices.get(id) || null;\n    }\n    hasVertex(id) {\n        return this.vertices.has(id);\n    }\n    removeVertex(id) {\n        if (this.inEdges.has(id)) {\n            const ins = this.inEdges.get(id);\n            for (const other of ins) {\n                if (this.outEdges.has(other)) {\n                    this.outEdges.get(other).delete(id);\n                }\n            }\n            this.inEdges.delete(id);\n        }\n        if (this.outEdges.has(id)) {\n            const ins = this.outEdges.get(id);\n            for (const other of ins) {\n                if (this.inEdges.has(other)) {\n                    this.inEdges.get(other).delete(id);\n                }\n            }\n            this.outEdges.delete(id);\n        }\n        this.vertices.delete(id);\n    }\n    addEdge(...edges) {\n        for (const edge of edges) {\n            if (this.vertices.has(edge[0]) && this.vertices.has(edge[1])) {\n                this.inEdges.get(edge[1]).add(edge[0]);\n                this.outEdges.get(edge[0]).add(edge[1]);\n            }\n            else {\n                throw new Error('Corresponding vertex(s) not found.');\n            }\n        }\n    }\n    removeEdge(edge) {\n        if (this.inEdges.has(edge[1]))\n            this.inEdges.get(edge[1]).delete(edge[0]);\n        if (this.outEdges.has(edge[0]))\n            this.outEdges.get(edge[0]).delete(edge[1]);\n    }\n    toposort(rootId) {\n        if (this.hasVertex(rootId)) {\n            return this.doTopoSort(rootId);\n        }\n        return [];\n    }\n    doTopoSort(node) {\n        const sorted = [];\n        const visited = {};\n        const visit = (nodeId, predecessors) => {\n            if (predecessors.has(nodeId)) {\n                throw new Error('Cyclic dependency delected for node ' + nodeId);\n            }\n            if (visited[nodeId]) {\n                return;\n            }\n            visited[nodeId] = true;\n            const outgoing = Array.from(this.outEdges.get(nodeId));\n            let i = outgoing.length;\n            if (i) {\n                predecessors.add(nodeId);\n                do {\n                    const child = outgoing[--i];\n                    visit(child, predecessors);\n                } while (i);\n                predecessors.delete(nodeId);\n            }\n            sorted.unshift(nodeId);\n        };\n        visit(node, new Set());\n        return sorted;\n    }\n}\n"],"names":["const","this","ins","other","let"],"mappings":"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"}