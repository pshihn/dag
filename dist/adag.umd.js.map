{"version":3,"file":"adag.umd.js","sources":["dag.js"],"sourcesContent":["export function createEdge(a, b) {\n    return [a.id, b.id];\n}\nexport class DAG {\n    constructor() {\n        this.vertices = new Map();\n        this.inEdges = new Map();\n        this.outEdges = new Map();\n    }\n    clear() {\n        this.vertices.clear();\n        this.inEdges.clear();\n        this.outEdges.clear();\n    }\n    addVertex(...vertices) {\n        for (const v of vertices) {\n            this.vertices.set(v.id, v);\n            this.inEdges.set(v.id, new Set());\n            this.outEdges.set(v.id, new Set());\n        }\n    }\n    getVertex(id) {\n        return this.vertices.get(id) || null;\n    }\n    hasVertex(id) {\n        return this.vertices.has(id);\n    }\n    removeVertex(id) {\n        if (this.inEdges.has(id)) {\n            const ins = this.inEdges.get(id);\n            for (const other of ins) {\n                if (this.outEdges.has(other)) {\n                    this.outEdges.get(other).delete(id);\n                }\n            }\n            this.inEdges.delete(id);\n        }\n        if (this.outEdges.has(id)) {\n            const ins = this.outEdges.get(id);\n            for (const other of ins) {\n                if (this.inEdges.has(other)) {\n                    this.inEdges.get(other).delete(id);\n                }\n            }\n            this.outEdges.delete(id);\n        }\n        this.vertices.delete(id);\n    }\n    addEdge(...edges) {\n        for (const edge of edges) {\n            if (this.vertices.has(edge[0]) && this.vertices.has(edge[1])) {\n                this.inEdges.get(edge[1]).add(edge[0]);\n                this.outEdges.get(edge[0]).add(edge[1]);\n            }\n            else {\n                throw new Error('Corresponding vertex(s) not found.');\n            }\n        }\n    }\n    removeEdge(edge) {\n        if (this.inEdges.has(edge[1]))\n            this.inEdges.get(edge[1]).delete(edge[0]);\n        if (this.outEdges.has(edge[0]))\n            this.outEdges.get(edge[0]).delete(edge[1]);\n    }\n    toposort(rootId) {\n        if (this.hasVertex(rootId)) {\n            return this.doTopoSort(rootId);\n        }\n        return [];\n    }\n    doTopoSort(node) {\n        const sorted = [];\n        const visited = {};\n        const visit = (nodeId, predecessors) => {\n            if (predecessors.has(nodeId)) {\n                throw new Error('Cyclic dependency delected for node ' + nodeId);\n            }\n            if (visited[nodeId]) {\n                return;\n            }\n            visited[nodeId] = true;\n            const outgoing = Array.from(this.outEdges.get(nodeId));\n            let i = outgoing.length;\n            if (i) {\n                predecessors.add(nodeId);\n                do {\n                    const child = outgoing[--i];\n                    visit(child, predecessors);\n                } while (i);\n                predecessors.delete(nodeId);\n            }\n            sorted.unshift(nodeId);\n        };\n        visit(node, new Set());\n        return sorted;\n    }\n}\n"],"names":["const","this","ins","other","let"],"mappings":";;;;;;IAAO,SAAS,WAAW,CAAG,EAAA,GAAG;QAC7B,OAAO,CAAC,CAAA,CAAE,GAAI,CAAA,CAAE;;;AAEpB,QAAa,MACT,eAAc;QACV,IAAA,CAAK,QAAL,GAAgB,IAAI,GAAJ;QAChB,IAAA,CAAK,OAAL,GAAe,IAAI,GAAJ;QACf,IAAA,CAAK,QAAL,GAAgB,IAAI,GAAJ;IACxB;kBACI,0BAAQ;QACJ,IAAA,CAAK,QAAL,CAAc,KAAd;QACA,IAAA,CAAK,OAAL,CAAa,KAAb;QACA,IAAA,CAAK,QAAL,CAAc,KAAd;IACR;kBACI,kCAAuB;;;;;aACd,kBAAW,mCAAU;YAArBA,IAAM;;gBACPC,MAAA,CAAK,QAAL,CAAc,GAAd,CAAkB,CAAA,CAAE,IAAI;YACxBA,MAAA,CAAK,OAAL,CAAa,GAAb,CAAiB,CAAA,CAAE,IAAI,IAAI,GAAJ;YACvBA,MAAA,CAAK,QAAL,CAAc,GAAd,CAAkB,CAAA,CAAE,IAAI,IAAI,GAAJ;;IAEpC;kBACI,gCAAU,IAAI;eACH,IAAA,CAAK,QAAL,CAAc,GAAd,CAAkB,GAAlB,IAAyB;IACxC;kBACI,gCAAU,IAAI;eACH,IAAA,CAAK,QAAL,CAAc,GAAd,CAAkB;IACjC;kBACI,sCAAa,IAAI;;;YACT,IAAA,CAAK,OAAL,CAAa,GAAb,CAAiB,KAAK;YACtBD,IAAM,MAAM,IAAA,CAAK,OAAL,CAAa,GAAb,CAAiB;iBACxB,kBAAe,8BAAK;gBAApBA,IAAM;;oBACP,IAAIC,MAAA,CAAK,QAAL,CAAc,GAAd,CAAkB,QAAQ;oBAC1BA,MAAA,CAAK,QAAL,CAAc,GAAd,CAAkB,MAAlB,CAAyB,MAAzB,CAAgC;;;gBAGxC,CAAK,OAAL,CAAa,MAAb,CAAoB;;YAEpB,IAAA,CAAK,QAAL,CAAc,GAAd,CAAkB,KAAK;YACvBD,IAAME,QAAM,IAAA,CAAK,QAAL,CAAc,GAAd,CAAkB;iBACzB,sBAAeA,sCAAK;gBAApBF,IAAMG;;oBACP,IAAIF,MAAA,CAAK,OAAL,CAAa,GAAb,CAAiBE,UAAQ;oBACzBF,MAAA,CAAK,OAAL,CAAa,GAAb,CAAiBE,QAAjB,CAAwB,MAAxB,CAA+B;;;gBAGvC,CAAK,QAAL,CAAc,MAAd,CAAqB;;YAEzB,CAAK,QAAL,CAAc,MAAd,CAAqB;IAC7B;kBACI,8BAAkB;;;;;aACT,kBAAc,gCAAO;YAArBH,IAAM;;gBACP,IAAIC,MAAA,CAAK,QAAL,CAAc,GAAd,CAAkB,IAAA,CAAK,GAAvB,IAA8BA,MAAA,CAAK,QAAL,CAAc,GAAd,CAAkB,IAAA,CAAK,KAAK;gBAC1DA,MAAA,CAAK,OAAL,CAAa,GAAb,CAAiB,IAAA,CAAK,GAAtB,CAA0B,GAA1B,CAA8B,IAAA,CAAK;gBACnCA,MAAA,CAAK,QAAL,CAAc,GAAd,CAAkB,IAAA,CAAK,GAAvB,CAA2B,GAA3B,CAA+B,IAAA,CAAK;mBAEnC;gBACD,MAAM,IAAI,KAAJ,CAAU;;;IAGhC;kBACI,kCAAW,MAAM;YACT,IAAA,CAAK,OAAL,CAAa,GAAb,CAAiB,IAAA,CAAK;cACtB,IAAA,CAAK,OAAL,CAAa,GAAb,CAAiB,IAAA,CAAK,GAAtB,CAA0B,MAA1B,CAAiC,IAAA,CAAK;YACtC,IAAA,CAAK,QAAL,CAAc,GAAd,CAAkB,IAAA,CAAK;cACvB,IAAA,CAAK,QAAL,CAAc,GAAd,CAAkB,IAAA,CAAK,GAAvB,CAA2B,MAA3B,CAAkC,IAAA,CAAK;IACnD;kBACI,8BAAS,QAAQ;QACb,IAAI,IAAA,CAAK,SAAL,CAAe,SAAS;YACxB,OAAO,IAAA,CAAK,UAAL,CAAgB;;eAEpB;IACf;kBACI,kCAAW,MAAM;;;QACbD,IAAM,SAAS;QACfA,IAAM,UAAU;YACV,kBAAS,MAAQ,EAAA,cAAT;YACV,IAAI,YAAA,CAAa,GAAb,CAAiB,SAAS;sBACpB,IAAI,KAAJ,CAAU,sCAAA,GAAyC;;YAE7D,IAAI,OAAA,CAAQ,SAAS;gBACjB;;YAEJ,OAAA,CAAQ,OAAR,GAAkB;YAClBA,IAAM,WAAW,KAAA,CAAM,IAAN,CAAWC,MAAA,CAAK,QAAL,CAAc,GAAd,CAAkB;YAC9CG,IAAI,IAAI,QAAA,CAAS;gBACb,GAAG;gBACH,YAAA,CAAa,GAAb,CAAiB;gBACjB,GAAG;wBACO,QAAQ,QAAA,CAAS,EAAE;oBACzB,KAAA,CAAM,OAAO;yBACR;gBACT,YAAA,CAAa,MAAb,CAAoB;;YAExB,MAAA,CAAO,OAAP,CAAe;;aAEnB,CAAM,MAAM,IAAI,GAAJ;eACL;IACf;;;;;;;;;;;;"}